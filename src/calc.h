#define _POSIX_C_SOURCE 200809L

#include <ctype.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Структура для стека
typedef struct {
    char** items;    // Элементы стека (массив указателей на строки)
    int top;         // Индекс верхнего элемента стека
    int capacity;    // Максимальное количество элементов в стеке
} Stack;

// Валидатор
bool validate_string(const char* str);
bool is_operator(char c);
bool has_function(const char* str, const char* func);

// Парсер
char** parse_string(const char* str);

// Работа со стеком
Stack* createStack(int capacity);
bool isEmpty(Stack* stack);
bool isFull(Stack* stack);
int push(Stack* stack, char* item);
char* pop(Stack* stack);
char* peek(Stack* stack);
void freeStack(Stack* stack);


// Вспомогательные функции
char* my_strdup(const char* s);
char* my_strndup(const char* s, size_t n);



// ДАЛЬНЕЙШИЙ ПЛАН:
// 1. Структура данных для стека: Начнем с создания структуры данных для стека, который будет использоваться в функции перевода в обратную польскую нотацию и в вычислительной функции.
// 2. Перевод в обратную польскую нотацию (ОПН): Функция, которая будет принимать математическое выражение и возвращать его в виде строки в ОПН.
// 3. Вычисление выражения в ОПН: Эта функция будет принимать строку в ОПН и возвращать численное значение выражения.
// 4. Рисование графиков: В СИ нет встроенных библиотек для графического интерфейса, похожих на qcustomplot из Qt. Для этого потребуется использовать сторонние библиотеки, такие как SDL или OpenGL, что делает задачу еще более сложной.



// Перевод выражения в обратную польскую нотацию и дальнейшие вычисления представляют собой интересную задачу. Я покажу, как это можно сделать, но обратите внимание, что рисование графика через qcustomplot требует графического интерфейса, который я не могу напрямую реализовать в этом текстовом формате. Я могу только предоставить инструкции или примеры кода.

// 1. Перевод в обратную польскую нотацию (ОПН):

// Нам нужно два стека: один для чисел (или промежуточных результатов) и один для операторов.

// Алгоритм:

// Читаем выражение слева направо.
// Если мы видим число, добавляем его в стек чисел.
// Если мы видим оператор (например, +, -, *, /), то пока на вершине стека операторов находится оператор с таким же или более высоким приоритетом, выталкиваем его из стека операторов и добавляем в стек чисел. Затем помещаем текущий оператор в стек операторов.
// Если мы видим скобку (, помещаем ее в стек операторов.
// Если мы видим скобку ), выталкиваем операторы из стека операторов и добавляем их в стек чисел, пока не встретим открывающую скобку.
// 2. Вычисление значения выражения в ОПН:

// Используем стек для вычисления значения выражения в ОПН:

// Читаем выражение слева направо.
// Если видим число, добавляем его в стек.
// Если видим оператор, выталкиваем два значения из стека, применяем оператор и помещаем результат обратно в стек.
// 3. Рисование графика функции:

// Для каждого значения 
// x
// x в интересующем нас диапазоне вычисляем значение 
// y
// y с помощью функции calculate, которая использует алгоритм ОПН, и рисуем точку (x, y) на графике.